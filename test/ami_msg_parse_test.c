#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <cmocka.h>

#include <stdio.h>

#include "amip.h"

static void parse_prompt_header_11 (void **state)
{
  (void)*state;
  const char *str = "Asterisk Call Manager/1.1\r\n";
  AMIVer ver;
  int ret = amiparse_prompt (str, &ver);
  assert_int_equal (RV_SUCCESS, ret);
  assert_int_equal (1, ver.major);
  assert_int_equal (1, ver.minor);
  assert_int_equal (0, ver.patch);
}

static void parse_prompt_header_280 (void **state)
{
  (void)*state;
  const char *str = "Asterisk Call Manager/2.8.4\r\n";
  AMIVer ver;
  int ret = amiparse_prompt (str, &ver);
  assert_int_equal (RV_SUCCESS, ret);
  assert_int_equal (2, ver.major);
  assert_int_equal (8, ver.minor);
  assert_int_equal (4, ver.patch);
}

static void parse_not_prompt_pack (void **state)
{
  (void)*state;
  const char *str = "Response: Success\r\n";
  AMIVer ver;
  int ret = amiparse_prompt (str, &ver);
  assert_int_equal (RV_FAIL, ret);
  assert_int_equal (0, ver.major);
  assert_int_equal (0, ver.minor);
  assert_int_equal (0, ver.patch);
}

static void parse_packet_stanza (void **state)
{
  (void)*state;
  int rv;
  //  "Action: CoreStatus\r\n\r\n"
  const char pack1[] = {0x41,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x43,0x6f,0x72,0x65,0x53,0x74,0x61,0x74,0x75,0x73,0x0d,0x0a,0x0d,0x0a};
  //  "Action: CoreStatus\r\n"
  const char pack2[] = {0x41,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x43,0x6f,0x72,0x65,0x53,0x74,0x61,0x74,0x75,0x73,0x0d,0x0a};
  //  "\r\n"
  const char pack3[] = {0x0d,0x0a};
  // empty string
  const char pack4[] = {};
  //  "\r\n\r\n"
  const char pack5[] = {0x0d,0x0a,0x0d,0x0a};
  //  "Stanza pack\r\n\r\n\r\n"
  const char pack6[] = {0x53,0x74,0x61,0x6e,0x7a,0x61,0x20,0x70,0x61,0x63,0x6b,0x0d,0x0a,0x0d,0x0a,0x0d,0x0a};

  assert_int_equal ( amiparse_stanza (pack1, sizeof(pack1)),
                      RV_SUCCESS);
  assert_int_equal ( amiparse_stanza (pack2, sizeof(pack2)),
                      RV_FAIL);
  assert_int_equal ( amiparse_stanza (pack3, sizeof(pack3)),
                      RV_FAIL);
  assert_int_equal ( amiparse_stanza (pack4, sizeof(pack4)),
                      RV_FAIL);
  assert_int_equal ( amiparse_stanza (pack5, sizeof(pack5)),
                      RV_SUCCESS);
  assert_int_equal ( amiparse_stanza (pack6, sizeof(pack6)),
                      RV_SUCCESS);

}

static void parse_packet_stanza_multiline (void **state)
{
  (void)*state;
  //"Action: CoreStatus\r\nActionID: 1q2w3e4\r\n\r\n"
  const char pack1[] = {0x41,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x43,0x6f,0x72,0x65,0x53,0x74,0x61,0x74,0x75,0x73,0x0d,0x0a,0x41,0x63,0x74,0x69,0x6f,0x6e,0x49,0x44,0x3a,0x20,0x31,0x71,0x32,0x77,0x33,0x65,0x34,0x0d,0x0a,0x0d,0x0a};
  //"Action: CoreStatus\r\n\r\nActionID: 1q2w3e4\r\n"
  const char pack2[] = {0x41,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x43,0x6f,0x72,0x65,0x53,0x74,0x61,0x74,0x75,0x73,0x0d,0x0a,0x0d,0x0a,0x41,0x63,0x74,0x69,0x6f,0x6e,0x49,0x44,0x3a,0x20,0x31,0x71,0x32,0x77,0x33,0x65,0x34,0x0d,0x0a};
  /*
    "Action: Redirect\r\n"
    "Channel: SIP/5558877449-C-00006cf\r\n"
    "ExtraChannel: SIP/258-C-000069a\r\n"
    "Context: outbound-local\r\n"
    "ExtraContext: extens-internal\r\n"
    "Priority: 1\r\n"
    "ExtraPriority: 1\r\n\r\n"
  */
  const char pack3[] = {0x41,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x52,0x65,0x64,0x69,0x72,0x65,0x63,0x74,0x0d,0x0a,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x3a,0x20,0x53,0x49,0x50,0x2f,0x35,0x35,0x35,0x38,0x38,0x37,0x37,0x34,0x34,0x39,0x2d,0x43,0x2d,0x30,0x30,0x30,0x30,0x36,0x63,0x66,0x0d,0x0a,0x45,0x78,0x74,0x72,0x61,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x3a,0x20,0x53,0x49,0x50,0x2f,0x32,0x35,0x38,0x2d,0x43,0x2d,0x30,0x30,0x30,0x30,0x36,0x39,0x61,0x0d,0x0a,0x43,0x6f,0x6e,0x74,0x65,0x78,0x74,0x3a,0x20,0x6f,0x75,0x74,0x62,0x6f,0x75,0x6e,0x64,0x2d,0x6c,0x6f,0x63,0x61,0x6c,0x0d,0x0a,0x45,0x78,0x74,0x72,0x61,0x43,0x6f,0x6e,0x74,0x65,0x78,0x74,0x3a,0x20,0x65,0x78,0x74,0x65,0x6e,0x73,0x2d,0x69,0x6e,0x74,0x65,0x72,0x6e,0x61,0x6c,0x0d,0x0a,0x50,0x72,0x69,0x6f,0x72,0x69,0x74,0x79,0x3a,0x20,0x31,0x0d,0x0a,0x45,0x78,0x74,0x72,0x61,0x50,0x72,0x69,0x6f,0x72,0x69,0x74,0x79,0x3a,0x20,0x31,0x0d,0x0a,0x0d,0x0a};
  /*
    "Action: Redirect\r\n"
    "Channel: SIP/5558877449-C-00006cf\r\n"
    "ExtraChannel: SIP/258-C-000069a\r\na\r\n"
  */
  const char pack4[] = {0x41,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x52,0x65,0x64,0x69,0x72,0x65,0x63,0x74,0x0d,0x0a,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x3a,0x20,0x53,0x49,0x50,0x2f,0x35,0x35,0x35,0x38,0x38,0x37,0x37,0x34,0x34,0x39,0x2d,0x43,0x2d,0x30,0x30,0x30,0x30,0x36,0x63,0x66,0x0d,0x0a,0x45,0x78,0x74,0x72,0x61,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x3a,0x20,0x53,0x49,0x50,0x2f,0x32,0x35,0x38,0x2d,0x43,0x2d,0x30,0x30,0x30,0x30,0x36,0x39,0x61,0x0d,0x0a,0x61,0x0d,0x0a};
  //"Action: CoreStatus\r\n\r\nActionID: 1q2w3e4\r\n\r\n\r\n"
  const char pack5[] = {0x41,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x43,0x6f,0x72,0x65,0x53,0x74,0x61,0x74,0x75,0x73,0x0d,0x0a,0x0d,0x0a,0x41,0x63,0x74,0x69,0x6f,0x6e,0x49,0x44,0x3a,0x20,0x31,0x71,0x32,0x77,0x33,0x65,0x34,0x0d,0x0a,0x0d,0x0a,0x0d,0x0a};
  //"Action: CoreStatus\r\n\r\nActionID: 1q2w3e4\r\n\r\n\r\n\r\n"
  const char pack6[] = {0x41,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x43,0x6f,0x72,0x65,0x53,0x74,0x61,0x74,0x75,0x73,0x0d,0x0a,0x0d,0x0a,0x41,0x63,0x74,0x69,0x6f,0x6e,0x49,0x44,0x3a,0x20,0x31,0x71,0x32,0x77,0x33,0x65,0x34,0x0d,0x0a,0x0d,0x0a,0x0d,0x0a,0x0d,0x0a};

  assert_int_equal(amiparse_stanza (pack1, sizeof(pack1)), RV_SUCCESS);
  assert_int_equal(amiparse_stanza (pack2, sizeof(pack2)), RV_FAIL);
  assert_int_equal(amiparse_stanza (pack3, sizeof(pack3)), RV_SUCCESS);
  assert_int_equal(amiparse_stanza (pack4, sizeof(pack4)), RV_FAIL);
  assert_int_equal(amiparse_stanza (pack5, sizeof(pack5)), RV_SUCCESS);
  assert_int_equal(amiparse_stanza (pack6, sizeof(pack6)), RV_SUCCESS);
}

static void parse_action_one_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value
  const char *str = "Action: CoreStatus\r\n\r\n";

  pack = amiparse_pack (str);
  assert_int_equal (AMI_ACTION, pack->type);
  assert_int_equal (pack->size, 1);
  hv = amiheader_value(pack, Action);
  assert_string_equal(hv->buf, "CoreStatus");
  amipack_destroy (pack);
}

static void parse_event_one_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value
  const char *str = "Event: FullyBooted\r\n\r\n";

  pack = amiparse_pack (str);
  assert_int_equal (pack->type, AMI_EVENT);
  assert_int_equal (pack->size, 1);
  hv = amiheader_value(pack, Event);
  assert_string_equal(hv->buf, "FullyBooted");
  amipack_destroy (pack);
}

static void parse_response_one_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value
  const char *str = "Response: Success\r\n\r\n";

  pack = amiparse_pack (str);
  assert_int_equal (pack->type, AMI_RESPONSE);
  assert_int_equal (pack->size, 1);
  hv = amiheader_value(pack, Response);
  assert_string_equal(hv->buf, "Success");
  amipack_destroy (pack);
}

static void parse_unknown_one_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value
  const char *str = "Unknown-Header_Name: Unknown AMI Packet\r\n\r\n";

  pack = amiparse_pack (str);
  assert_non_null (pack);
  assert_int_equal (pack->type, AMI_UNKNOWN);
  assert_int_equal (pack->size, 1);
  amipack_destroy (pack);
}

static void parse_invalid_pack (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value
  const char *str = "invalid pack that match stanza\r\n\r\n";

  pack = amiparse_pack (str);
  assert_null (pack);
}

static void parse_response_one_header_caseinsen (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value
  const char *str = "response: Fail\r\n\r\n";

  pack = amiparse_pack (str);
  assert_int_equal (pack->type, AMI_RESPONSE);
  assert_int_equal (pack->size, 1);
  hv = amiheader_value(pack, Response);
  assert_string_equal(hv->buf, "Fail");
  amipack_destroy (pack);
}

static void parse_multi_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value

  /*
     "Event: Hangup\r\n"
     "Privilege: call,all\r\n"
     "Channel: SIP/ipauthTp3BCHH7-00573401\r\n"
     "Uniqueid: 1486254977.6071371\r\n"
     "CallerIDNum: 18072280333\r\n"
     "CallerIDName: <unknown>\r\n"
     "ConnectedLineNum: 16478472022\r\n"
     "ConnectedLineName: John Bar\r\n"
     "Cause: 16\r\n"
     "Cause-txt: Normal Clearing\r\n\r\n";
  */
  const char str_pack[] = {0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x48,0x61,0x6e,0x67,0x75,0x70,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,0x6c,0x65,0x67,0x65,0x3a,0x20,0x63,0x61,0x6c,0x6c,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x3a,0x20,0x53,0x49,0x50,0x2f,0x69,0x70,0x61,0x75,0x74,0x68,0x54,0x70,0x33,0x42,0x43,0x48,0x48,0x37,0x2d,0x30,0x30,0x35,0x37,0x33,0x34,0x30,0x31,0x0d,0x0a,0x55,0x6e,0x69,0x71,0x75,0x65,0x69,0x64,0x3a,0x20,0x31,0x34,0x38,0x36,0x32,0x35,0x34,0x39,0x37,0x37,0x2e,0x36,0x30,0x37,0x31,0x33,0x37,0x31,0x0d,0x0a,0x43,0x61,0x6c,0x6c,0x65,0x72,0x49,0x44,0x4e,0x75,0x6d,0x3a,0x20,0x31,0x38,0x30,0x37,0x32,0x32,0x38,0x30,0x33,0x33,0x33,0x0d,0x0a,0x43,0x61,0x6c,0x6c,0x65,0x72,0x49,0x44,0x4e,0x61,0x6d,0x65,0x3a,0x20,0x3c,0x75,0x6e,0x6b,0x6e,0x6f,0x77,0x6e,0x3e,0x0d,0x0a,0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x65,0x64,0x4c,0x69,0x6e,0x65,0x4e,0x75,0x6d,0x3a,0x20,0x31,0x36,0x34,0x37,0x38,0x34,0x37,0x32,0x30,0x32,0x32,0x0d,0x0a,0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x65,0x64,0x4c,0x69,0x6e,0x65,0x4e,0x61,0x6d,0x65,0x3a,0x20,0x4a,0x6f,0x68,0x6e,0x20,0x42,0x61,0x72,0x0d,0x0a,0x43,0x61,0x75,0x73,0x65,0x3a,0x20,0x31,0x36,0x0d,0x0a,0x43,0x61,0x75,0x73,0x65,0x2d,0x74,0x78,0x74,0x3a,0x20,0x4e,0x6f,0x72,0x6d,0x61,0x6c,0x20,0x43,0x6c,0x65,0x61,0x72,0x69,0x6e,0x67,0x0d,0x0a,0x0d,0x0a};

  ret = amiparse_stanza (str_pack, sizeof(str_pack));
  assert_int_equal (RV_SUCCESS, ret);

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_EVENT, pack->type);
  assert_int_equal (pack->size, 10);

  hv = amiheader_value(pack, Event);
  assert_memory_equal (hv->buf, "Hangup", hv->len);

  hv = amiheader_value(pack, Privilege);
  assert_memory_equal (hv->buf, "call,all", hv->len);

  hv = amiheader_value(pack, Channel);
  assert_memory_equal (hv->buf, "SIP/ipauthTp3BCHH7-00573401", hv->len);

  hv = amiheader_value(pack, Uniqueid);
  assert_memory_equal (hv->buf, "1486254977.6071371", hv->len);

  hv = amiheader_value(pack, CallerIDNum);
  assert_memory_equal (hv->buf, "18072280333", hv->len);

  hv = amiheader_value(pack, CallerIDName);
  assert_memory_equal (hv->buf, "<unknown>", hv->len);

  hv = amiheader_value(pack, ConnectedLineNum);
  assert_memory_equal (hv->buf, "16478472022", hv->len);

  hv = amiheader_value(pack, ConnectedLineName);
  assert_memory_equal (hv->buf, "John Bar", hv->len);

  hv = amiheader_value(pack, Cause);
  assert_memory_equal (hv->buf, "16", hv->len);

  hv = amiheader_value(pack, Cause_txt);
  assert_memory_equal (hv->buf, "Normal Clearing", hv->len);

  amipack_destroy (pack);
}

static void parse_headers_with_empty_value (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value

  /*
    "Event: Newchannel\r\n"
    "Privilege: call,all\r\n"
    "Channel: SIP/ipauthTp3BCHH7-00573539\r\n"
    "ChannelState: 0\r\n"
    "ChannelStateDesc: Down\r\n"
    "CallerIDNum: \r\n"
    "CallerIDName: \r\n"
    "AccountCode: 81\r\n"
    "Exten: \r\n"
    "Context: mor\r\n"
    "Uniqueid: 1486256739.6071687\r\n\r\n";
  */
  const char str_pack[] = {0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x4e,0x65,0x77,0x63,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,0x6c,0x65,0x67,0x65,0x3a,0x20,0x63,0x61,0x6c,0x6c,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x3a,0x20,0x53,0x49,0x50,0x2f,0x69,0x70,0x61,0x75,0x74,0x68,0x54,0x70,0x33,0x42,0x43,0x48,0x48,0x37,0x2d,0x30,0x30,0x35,0x37,0x33,0x35,0x33,0x39,0x0d,0x0a,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x53,0x74,0x61,0x74,0x65,0x3a,0x20,0x30,0x0d,0x0a,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x53,0x74,0x61,0x74,0x65,0x44,0x65,0x73,0x63,0x3a,0x20,0x44,0x6f,0x77,0x6e,0x0d,0x0a,0x43,0x61,0x6c,0x6c,0x65,0x72,0x49,0x44,0x4e,0x75,0x6d,0x3a,0x20,0x0d,0x0a,0x43,0x61,0x6c,0x6c,0x65,0x72,0x49,0x44,0x4e,0x61,0x6d,0x65,0x3a,0x20,0x0d,0x0a,0x41,0x63,0x63,0x6f,0x75,0x6e,0x74,0x43,0x6f,0x64,0x65,0x3a,0x20,0x38,0x31,0x0d,0x0a,0x45,0x78,0x74,0x65,0x6e,0x3a,0x20,0x0d,0x0a,0x43,0x6f,0x6e,0x74,0x65,0x78,0x74,0x3a,0x20,0x6d,0x6f,0x72,0x0d,0x0a,0x55,0x6e,0x69,0x71,0x75,0x65,0x69,0x64,0x3a,0x20,0x31,0x34,0x38,0x36,0x32,0x35,0x36,0x37,0x33,0x39,0x2e,0x36,0x30,0x37,0x31,0x36,0x38,0x37,0x0d,0x0a,0x0d,0x0a};

  ret = amiparse_stanza (str_pack, sizeof(str_pack));
  assert_int_equal (RV_SUCCESS, ret);

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_EVENT, pack->type);

  assert_int_equal (pack->size, 11);
  assert_int_equal (amipack_length(pack), sizeof(str_pack));

  hv = amiheader_value(pack, Event);
  assert_string_equal(hv->buf, "Newchannel");

  hv = amiheader_value(pack, ChannelStateDesc);
  assert_string_equal(hv->buf, "Down");

  hv = amiheader_value(pack, CallerIDName);
  assert_string_equal(hv->buf, "");

  hv = amiheader_value(pack, Exten);
  assert_string_equal(hv->buf, "");

  hv = amiheader_value(pack, Uniqueid);
  assert_string_equal(hv->buf, "1486256739.6071687");

  amipack_destroy (pack);
}

static void parse_pack_with_empty_last_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value

  /*
    "Event: Custom\r\n"
    "Privilege: call,all\r\n"
    "Exten: \r\n"
    "Peer: \r\n\r\n";
  */
  const char str_pack[] = {0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x43,0x75,0x73,0x74,0x6f,0x6d,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,0x6c,0x65,0x67,0x65,0x3a,0x20,0x63,0x61,0x6c,0x6c,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x45,0x78,0x74,0x65,0x6e,0x3a,0x20,0x0d,0x0a,0x50,0x65,0x65,0x72,0x3a,0x20,0x0d,0x0a,0x0d,0x0a};

  ret = amiparse_stanza (str_pack, sizeof(str_pack));
  assert_int_equal (RV_SUCCESS, ret);

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_EVENT, pack->type);

  assert_int_equal (pack->size, 4);
  assert_int_equal (amipack_length(pack), sizeof(str_pack));

  hv = amiheader_value(pack, Event);
  assert_string_equal(hv->buf, "Custom");

  hv = amiheader_value(pack, Peer);
  assert_string_equal(hv->buf, "");

  amipack_destroy (pack);
}

static void parse_pack_unordered (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value

  /*
    "Status: Fully Booted\r\n"
    "Exten: \r\n"
    "Event: FullyBooted\r\n"
    "Privilege: system,all\r\n\r\n";
  */
  const char str_pack[] = {0x53,0x74,0x61,0x74,0x75,0x73,0x3a,0x20,0x46,0x75,0x6c,0x6c,0x79,0x20,0x42,0x6f,0x6f,0x74,0x65,0x64,0x0d,0x0a,0x45,0x78,0x74,0x65,0x6e,0x3a,0x20,0x0d,0x0a,0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x46,0x75,0x6c,0x6c,0x79,0x42,0x6f,0x6f,0x74,0x65,0x64,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,0x6c,0x65,0x67,0x65,0x3a,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x0d,0x0a};

  ret = amiparse_stanza (str_pack, sizeof(str_pack));
  assert_int_equal (RV_SUCCESS, ret);

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_EVENT, pack->type);

  hv = amiheader_value(pack, Event);
  assert_string_equal(hv->buf, "FullyBooted");

  amipack_destroy (pack);
}

static void parse_pack_with_invalid_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value

  /*
    "Event: FullyBooted\r\n"
    "invalid header\r\n"
    "Exten: \r\n"
    "Privilege: system,all\r\n\r\n";
  */
  const char str_pack[] = {0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x46,0x75,0x6c,0x6c,0x79,0x42,0x6f,0x6f,0x74,0x65,0x64,0x0d,0x0a,0x69,0x6e,0x76,0x61,0x6c,0x69,0x64,0x20,0x68,0x65,0x61,0x64,0x65,0x72,0x0d,0x0a,0x45,0x78,0x74,0x65,0x6e,0x3a,0x20,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,0x6c,0x65,0x67,0x65,0x3a,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x0d,0x0a};

  ret = amiparse_stanza (str_pack, sizeof(str_pack));
  assert_int_equal (RV_SUCCESS, ret);

  assert_null(amiparse_pack (str_pack));

}

static void parse_pack_command_output (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value

  const char str_pack[] = "Response: Follows\r\n"
                          "ActionID: 12345\r\n"
                          "Privilege: Command\r\n"
                          "Channel              Location             State   Application(Data)             \n"
                          "Local/5143607296@dia IVR_603@default:1    Up      AppDial((Outgoing Line))      \n"
                          "Local/5146020115@dia 5146020115@dial-foll Ring    Dial(SIP/5146020115@drspa.ntek\n"
                          "1754093 calls processed\n"
                          "--END COMMAND--\r\n\r\n";

  const char output_cmp[] = "Channel              Location             State   Application(Data)             \n"
                          "Local/5143607296@dia IVR_603@default:1    Up      AppDial((Outgoing Line))      \n"
                          "Local/5146020115@dia 5146020115@dial-foll Ring    Dial(SIP/5146020115@drspa.ntek\n"
                          "1754093 calls processed\n";

  ret = amiparse_stanza (str_pack, sizeof(str_pack) - 1); // -1 to remove last \000
  assert_int_equal (RV_SUCCESS, ret);

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_RESPONSE, pack->type);

  hv = amiheader_value(pack, Privilege);
  assert_string_equal(hv->buf, "Command");

  hv = amiheader_value(pack, ActionID);
  assert_string_equal(hv->buf, "12345");

  hv = amiheader_value(pack, Output);
  assert_string_equal(hv->buf, output_cmp);

  amipack_destroy (pack);
}

/*
 * Command output compatibale with AMI v2
 * Command output is a value of the header "Output: "
 */
static void parse_pack_command_output_v2 (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *hv; // header value

  const char str_pack[] = "Response: Follows\r\n"
                          "Message: Command output follows\r\n"
                          "Output: Name/username             Host                                    Dyn Forcerport Comedia    ACL Port     Status      Description                      \r\n"
                          "8888/8888                 (Unspecified)                            D  Auto (No)  No             0        Unmonitored                                  \n"
                          "1 sip peers [Monitored: 0 online, 0 offline Unmonitored: 0 online, 1 offline]\n"
                          "--END COMMAND--\r\n\r\n";

  const char output_cmp[] = "Output: Name/username             Host                                    Dyn Forcerport Comedia    ACL Port     Status      Description                      \r\n"
                          "8888/8888                 (Unspecified)                            D  Auto (No)  No             0        Unmonitored                                  \n"
                          "1 sip peers [Monitored: 0 online, 0 offline Unmonitored: 0 online, 1 offline]\n";

  ret = amiparse_stanza (str_pack, sizeof(str_pack) - 1);
  assert_int_equal (RV_SUCCESS, ret);

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_RESPONSE, pack->type);

  hv = amiheader_value(pack, Message);
  assert_string_equal(hv->buf, "Command output follows");

  hv = amiheader_value(pack, Output);
  assert_string_equal(hv->buf, output_cmp);

  amipack_destroy (pack);
}

static void parse_pack_with_multiple_unknown_headers (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  struct str *pack_str;

  const char inpack[] = {0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x53,0x75,0x63,0x63,0x65,0x73,0x73,0x66,0x75,0x6c,0x41,0x75,0x74,0x68,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,
    0x6c,0x65,0x67,0x65,0x3a,0x20,0x73,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x45,0x76,0x65,0x6e,0x74,0x54,0x56,0x3a,
    0x20,0x32,0x30,0x31,0x37,0x2d,0x30,0x34,0x2d,0x30,0x32,0x54,0x31,0x35,0x3a,0x35,0x32,0x3a,0x30,0x38,0x2e,0x30,0x33,0x34,0x2d,0x30,0x34,0x30,
    0x30,0x0d,0x0a,0x53,0x65,0x76,0x65,0x72,0x69,0x74,0x79,0x3a,0x20,0x49,0x6e,0x66,0x6f,0x72,0x6d,0x61,0x74,0x69,0x6f,0x6e,0x61,0x6c,0x0d,0x0a,
    0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x3a,0x20,0x41,0x4d,0x49,0x0d,0x0a,0x45,0x76,0x65,0x6e,0x74,0x56,0x65,0x72,0x73,0x69,0x6f,0x6e,0x3a,0x20,
    0x31,0x0d,0x0a,0x41,0x63,0x63,0x6f,0x75,0x6e,0x74,0x49,0x44,0x3a,0x20,0x61,0x64,0x6d,0x69,0x6e,0x0d,0x0a,0x53,0x65,0x73,0x73,0x69,0x6f,0x6e,
    0x49,0x44,0x3a,0x20,0x30,0x78,0x61,0x31,0x33,0x34,0x65,0x64,0x63,0x0d,0x0a,0x4c,0x6f,0x63,0x61,0x6c,0x41,0x64,0x64,0x72,0x65,0x73,0x73,0x3a,
    0x20,0x49,0x50,0x56,0x34,0x2f,0x54,0x43,0x50,0x2f,0x30,0x2e,0x30,0x2e,0x30,0x2e,0x30,0x2f,0x35,0x30,0x33,0x38,0x0d,0x0a,0x52,0x65,0x6d,0x6f,
    0x74,0x65,0x41,0x64,0x64,0x72,0x65,0x73,0x73,0x3a,0x20,0x49,0x50,0x56,0x34,0x2f,0x54,0x43,0x50,0x2f,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,
    0x31,0x2e,0x31,0x32,0x32,0x2f,0x35,0x30,0x34,0x34,0x38,0x0d,0x0a,0x55,0x73,0x69,0x6e,0x67,0x50,0x61,0x73,0x73,0x77,0x6f,0x72,0x64,0x3a,0x20,
    0x30,0x0d,0x0a,0x53,0x65,0x73,0x73,0x69,0x6f,0x6e,0x54,0x56,0x3a,0x20,0x32,0x30,0x31,0x37,0x2d,0x30,0x34,0x2d,0x30,0x32,0x54,0x31,0x35,0x3a,
    0x35,0x32,0x3a,0x30,0x38,0x2e,0x30,0x33,0x34,0x2d,0x30,0x34,0x30,0x30,0x0d,0x0a,0x0d,0x0a};

  ret = amiparse_stanza (inpack, sizeof(inpack));
  assert_int_equal (RV_SUCCESS, ret);

  pack = amiparse_pack (inpack);
  assert_int_equal (AMI_EVENT, pack->type);

  pack_str = amipack_to_str(pack);
  assert_memory_equal (pack_str->buf, inpack, pack_str->len);

  str_destroy(pack_str);
  amipack_destroy (pack);
}

int main(void)
{
  const struct CMUnitTest tests[] = {
    cmocka_unit_test (parse_prompt_header_11),
    cmocka_unit_test (parse_prompt_header_280),
    cmocka_unit_test (parse_not_prompt_pack),
    cmocka_unit_test (parse_packet_stanza),
    cmocka_unit_test (parse_packet_stanza_multiline),
    cmocka_unit_test (parse_action_one_header),
    cmocka_unit_test (parse_event_one_header),
    cmocka_unit_test (parse_response_one_header),
    cmocka_unit_test (parse_unknown_one_header),
    cmocka_unit_test (parse_invalid_pack),
    cmocka_unit_test (parse_response_one_header_caseinsen),
    cmocka_unit_test (parse_multi_header),
    cmocka_unit_test (parse_headers_with_empty_value),
    cmocka_unit_test (parse_pack_with_empty_last_header),
    cmocka_unit_test (parse_pack_unordered),
    cmocka_unit_test (parse_pack_with_invalid_header),
    cmocka_unit_test (parse_pack_command_output),
    cmocka_unit_test (parse_pack_command_output_v2),
    cmocka_unit_test (parse_pack_with_multiple_unknown_headers),
  };

  cmocka_set_message_output(CM_OUTPUT_TAP);

  return cmocka_run_group_tests_name("Parse AMI package tests.", tests, NULL, NULL);
}
